<html>
	<head>
		<style>
			body {
				background-color: darkgray;
			}
			
			table, td, th {
				border: 1px solid;
			}
		</style>
		<script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
	</head>
	<body>
		<input type="text" id="itemId">
		<input type="text" id="world">
		<input type="text" id="region">

		<table id="data-table">
			<thead>
				<tr>
					<td>Image</td>
					<td>Name</td>
					<td>Amount</td>
					<td>Cheapest current price per unit NQ (region)</td>
					<td>World</td>
					<td>Cheapest current price per unit HQ (region)</td>
					<td>World</td>
					<td>Average sale price NQ (world)</td>
					<td>Average sale price HQ (world)</td>
				</tr>
			</thead>
			<tbody></tbody>
		</table>
		
		<div id="error" style="color: red;"></div>
	</body>
</html>

<script>
$(document).ready(() => {
	$("#itemId").val(26782);
	$("#world").val("Louisoix");
	$("#region").val("Europe");
	init();
});

$("#itemId").change(() => {
	init();
});

async function init() {
	const error = $("#error");
	const table = $("tbody");
	const itemId = $("#itemId").val();
	const world = $("#world").val();
	const region = $("#region").val();

	error.html("");
	table.html("");

	try {
		let item = await fetchCraftedItem(itemId);
		
		const recipe = await fetchRecipe(item.Recipes[0].ID);

		item = await calculatePrices(item, region, world);
		item["amount"] = recipe.AmountResult;

		drawItemRow(item);
		
		let ingredients = [];
		if (recipe.AmountResult) {
			let ingredientAmount = 0;
			let checking = true;

			while (checking) {
				if (recipe["AmountIngredient" + ingredientAmount] === undefined) {
					checking = false;
				} else if (recipe["AmountIngredient" + ingredientAmount]) {
					ingredients.push({ amount: recipe["AmountIngredient" + ingredientAmount], ...recipe["ItemIngredient" + ingredientAmount] });
				}

				ingredientAmount++;
			}
		} else {
			throw new Error("Item is not a recipe.");
		}

		for (ingredient of ingredients) {
			ingredient = { amount: ingredient.amount, ...await calculatePrices(ingredient, region, world) };
			drawItemRow(ingredient);
		}
	} catch (ex) {
		error.html(ex);
	}
}

async function calculatePrices(item, region, world) {
	const marketData = await fetchMarketDataForItem(region, item.ID);

	let minListingNQ = marketData.listings.filter((listing) => listing.hq == false);
	let minListingHQ = marketData.listings.filter((listing) => listing.hq == true);

	if (minListingNQ.length > 0) {
		minListingNQ = minListingNQ.reduce((previous, current) => current.pricePerUnit < previous.pricePerUnit ? current : previous);
	}

	if (minListingHQ.length > 0) {
		minListingHQ = minListingHQ.reduce((previous, current) => current.pricePerUnit < previous.pricePerUnit ? current : previous);
	}

	const latestPrices = await fetchLatestSalesForItem(world, item.ID);

	let latestSalesNQ = latestPrices.entries.filter((listing) => listing.hq == false);
	let latestSalesHQ = latestPrices.entries.filter((listing) => listing.hq == true);

	let averagePriceNQ;
	let averagePriceHQ;

	if (latestSalesNQ.length > 0) {
		let total = latestSalesNQ.reduce((value, entry) => value + entry.pricePerUnit, 0);
		averagePriceNQ = total / latestSalesNQ.length;
	}

	if (latestSalesHQ.length > 0) {
		let total = latestSalesHQ.reduce((value, entry) => value + entry.pricePerUnit, 0);
		averagePriceHQ = total / latestSalesHQ.length;
	}

	return { item, minListingNQ, minListingHQ, averagePriceNQ, averagePriceHQ };
}

function drawItemRow(item) {
	let html = "";

	html += "<tr>";
	html += "<td><img src=\"" + "https://xivapi.com/" + item.item.Icon + "\"></td>";
	html += "<td>" + item.item.Name + "</td>";
	html += "<td>" + item.amount + "</td>";
	html += "<td>" + new Intl.NumberFormat().format(item.minListingNQ.pricePerUnit) + "</td>";
	html += "<td>" + item.minListingNQ.worldName + "</td>";
	html += "<td>" + new Intl.NumberFormat().format(item.minListingHQ.pricePerUnit) + "</td>";
	html += "<td>" + item.minListingHQ.worldName + "</td>";
	html += "<td>" + new Intl.NumberFormat().format(item.averagePriceNQ) + "</td>";
	html += "<td>" + new Intl.NumberFormat().format(item.averagePriceHQ) + "</td>";
	html += "</tr>";

	$("#data-table").append(html);
}

function fetchMarketDataForItem(region, itemId) {
	return $.get("https://universalis.app/api/v2/" + region + "/" + itemId, (data) => data)
	.fail((error) => {
		throw new Error(error.Message);
	});
}

function fetchLatestSalesForItem(world, itemId) {
	const lastMonthMili = 2592000000;

	return $.get("https://universalis.app/api/v2/history/" + world + "/" + itemId + "?statsWithin=" + lastMonthMili, (data) => data)
	.fail((error) => {
		throw new Error(error.Message);
	});
}

function fetchCraftedItem(itemId) {
	return $.get("https://xivapi.com/item/" + itemId, (item) => {
		if (item.Recipes) {
			return item;
		} else {
			throw new Error("Item is not a recipe.");
		}
	})
	.fail((error) => {
		throw new Error(error.Message);
	});
}

function fetchRecipe(recipeId) {
	return $.get("https://xivapi.com/recipe/" + recipeId, (recipe) => recipe)
	.fail((error) => {
		throw new Error(error.Message);
	});
}
</script>